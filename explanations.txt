1. Using grep -Po '(\d+\.\d+)\s+id'
cpu_idle=$(top -bn1 | grep "Cpu(s)" | grep -Po '(\d+\.\d+)\s+id' | awk '{print $1}')
cpu_usage=$(echo "100 - $cpu_idle" | bc)
echo "CPU Usage: $cpu_usage%"

Explanation:

grep -Po → Perl regex mode.
digit+.digit+ space

(\d+\.\d+)\s+id → capture the floating-point number before id (the idle %).

Example: 

%Cpu(s):  3.0 us,  1.0 sy,  0.0 ni, 95.0 id,  1.0 wa
it extracts 95.0 id → keeps 95.0.
Then: 100 - idle = usage.

2.Disk (df /)

Raw output looks like:

Filesystem     1K-blocks    Used Available Use% Mounted on
/dev/sda1      488281250 3000000 188281250  67% /


NR==2 → second line only
$5 = Use% → 67%
Strip % → 67
Script prints: 67% Disk usage

3. 1. CPU (top -bn1 | grep "Cpu(s)")

Raw output looks like:

%Cpu(s):  3.0 us,  1.0 sy,  0.0 ni, 95.0 id,  1.0 wa,  0.0 hi,  0.0 si,  0.0 st


us = user space %

sy = system (kernel) %

ni = nice (low-priority) %

id = idle % ← we grab this

wa = waiting for I/O %

hi = hardware interrupts %

si = software interrupts %

st = stolen by hypervisor %

Script does: 100 − 95.0 (idle) = 5% CPU usage

4. Memory (free)

Raw output looks like:

              total        used        free      shared  buff/cache   available
Mem:        16000000     4000000     2000000      500000     1000000    11000000
Swap:        2000000           0     2000000


$2 = total = 16000000 KB
$3 = used = 4000000 KB

Formula → (4000000 ÷ 16000000) × 100 = 25%